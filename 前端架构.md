# 前端工程化和架构设计
- 团队并非一个人单打独斗，那么如何设计工作流程，如何打造一个众人皆可赞的羡慕根基？
- 羡慕依赖纷繁复杂，如何做好依赖管理和公共库管理？
- 如何深入理解框架。真正做到框架的精通和技术选型的准确拿捏？
- 从最基本的网络请求库说起，如何设计一个稳定灵活的多端Fetch库？
- 如何借力low code / no code技术，实现越来越智能的应用搭建方案？
- 如何统一中后台项目架构，实现跨业务线的产研效率提升？
- 如何开发设计一套适合业务的组件库，封装分层样式，最大限度做到复用，提升开发效率？
- 如何执行跨端方案，White Once，Run Everywhere是否真的可行？
- 如何处理各种模块化规范，以及精确做到代码拆分的最佳实践？
- 如何区分开发边界，比如前端如何更好地利用node.js方案开疆拓土？

那具体什么是我们心中的“前端架构设计和工程化设计”呢?

# 知识体系
- 前端工程化管理工具
- 现代化前端开发和架构生态
- 核心框架原理与代码设计模式
- 前端架构设计实战
- 前端全链路--node.js全栈开发

# 前端工程化管理工具篇
## 1、npm安装机制及企业级部署私服原理
## 2、Yarn 的安装理念及如何破解依赖管理困境
## 3、CI环境上的npm优化及更多工程化问题解析
## 4、横向对比主流构建工具，了解构建工具的设计考量
## 5、Vite实现：从源码分析出发，构建bundleless开发工程

# 现代化前端架构的特点
- 组件化是基本UI架构
- 依托于SSR同构技术以及心智负担的最小化
- 数据状态管理方案将会以职责单一、minimal necessary为目标
- 前端向传统后端领域进军是必然，CSR/SSR可切换的协作方案

# 从CSR -> SSR -> NSR -> ESR 渲染方案演进看前端架构演进方向

## CSR：浏览器端渲染
特点：
- 实现了前后端架构分离，实现了前后端职责分离
- 首屏渲染时间比较久

## SSR: 服务器端渲染
- 流式SSR

    允许服务端通过stream的方式向浏览器发送HTML内容
    react实现：render To Node Stream

- 渐进式SSR

    允许hydrating没有完全结束前，部分已经渲染并注水完成的页面内容，可以优先完成交互相应

## NSR：
通过native渲染生成HTML数据，并且缓存在客户端
### 优点：将服务器的渲染工作放在了一个个独立的移动设备中，并借助离线存储技术实现了页面的预加载，同时又不会增加额外的服务器压力

## ESR：边缘渲染
### 更加激进：借助了最近几年较火的“边缘计算”能力
### 特点：
- 在CDN上缓存页面的静态部分，在用户访问页面时可以快速返回给用户静态类容
- 在CDN节点上也发起动态部分内容请求，在动态内容获取之后利用流的方式，继续返回给用户

# 1、npm安装机制及企业级部署私服原理
## 1.1问题
- 删除node_modules 和 lockfiles文件，再重新install，这样操作是否存在风险？

- 把所有依赖都安装到 dependencies中，不区分devDependencies会有问题吗？

- 应用依赖了公共库A和B，同时公共库A也依赖了公共库B，那么公共库B会被多次安装和重复打包吗？
    
    - 会。

- 一个项目中，即有人用npm也有人用yarn，会引发什么问题？

- 我们是否应该提交lockfiles文件到项目仓库呢？

## npm 缓存机制
- 命令 npm config get cache 可以看到缓存文件
- 命令 npm cache clean --force 清除__cacache文件中的内容

### 小技巧
- npm init 命令调用shell脚本输出一个初始化的package.json文件

## 扩展：
### npx？
    可以直接执行bin目录下的文件，所以比较快
### nrm
    npm的镜像源管理工具